'use strict';
import { SVGLoader } from 'threejs/addons/loaders/SVGLoader.js';
import { mergeBufferGeometries, mergeVertices } from 'threejs/addons/utils/BufferGeometryUtils.js';
import { GUI } from 'threejs/addons/libs/lil-gui.module.min.js';
import { GLTFExporter } from './jsm/exporters/GLTFExporter.js';

window.addEventListener('load', async e => {

    const params = threejs.AppUtils.getPageParams();
    const app = await createApp({
        containerId: 'threejs-container',
        fsButtonId: 'fullscreen-button',
        sceneURL: params.load || 'SVG to Mesh.gltf',
        logicURL: params.logic || 'visual_logic.js',
    });
});

async function createApp({containerId, fsButtonId = null, sceneURL, logicURL = ''}) {
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    // some puzzles can benefit from cache
    threejs.Cache.enabled = true;

    let PL = null, PE = null;
    if (threejs.AppUtils.isXML(logicURL)) {
        const PUZZLES_DIR = '/puzzles/';
        const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
        PL = await new threejs.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
        PE = threejs.PE;
    } else if (threejs.AppUtils.isJS(logicURL)) {
        PL = await new threejs.PuzzlesLoader().loadLogic(logicURL);
    }

    let initOptions = { useFullscreen: true };
    if (PL) {
        initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
    }
    sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

    const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
            initOptions.useFullscreen);
    const preloader = createPreloader(containerId, initOptions, PE);

    const app = createAppInstance(containerId, initOptions, preloader, PE);
    app.addEventListener('dispose', () => disposeFullscreen && disposeFullscreen());

    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    app.loadScene(sceneURL, async () => {
        // console.log('app: ', app);
        // calling to display svg model
        await displaySVG(app);
        app.enableControls();
        app.run();

        if (PE) PE.updateAppInstance(app);
        if (PL) PL.init(app, initOptions);

        runCode(app, PL);
        //console.log('app: ', app);
    }, null, () => {
        console.log(`Can't load the scene ${sceneURL}`);
    });

    return { app, PL };
}

function createPreloader(containerId, initOptions, PE) {
    const preloader = initOptions.useCustomPreloader
            ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
            : new threejs.SimplePreloader({ container: containerId });

    if (PE) puzzlesEditorPreparePreloader(preloader, PE);

    return preloader;
}

function createCustomPreloader(updateCb, finishCb) {
    function CustomPreloader() {
        threejs.Preloader.call(this);
    }

    CustomPreloader.prototype = Object.assign(Object.create(threejs.Preloader.prototype), {
        onUpdate: function(percentage) {
            threejs.Preloader.prototype.onUpdate.call(this, percentage);
            if (updateCb) updateCb(percentage);

        },
        onFinish: function() {
            threejs.Preloader.prototype.onFinish.call(this);
            if (finishCb) finishCb();
        }
    });

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
    const _onUpdate = preloader.onUpdate.bind(preloader);
    preloader.onUpdate = function(percentage) {
        _onUpdate(percentage);
        PE.loadingUpdateCb(percentage);
    }

    const _onFinish = preloader.onFinish.bind(preloader);
    preloader.onFinish = function() {
        _onFinish();
        PE.loadingFinishCb();
    }
}


function createAppInstance(containerId, initOptions, preloader, PE) {
    const ctxSettings = {};
    if (initOptions.useBkgTransp) ctxSettings.alpha = true;
    if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

    const app = new threejs.App(containerId, ctxSettings, preloader);
    if (initOptions.useBkgTransp) {
        app.clearBkgOnLoad = true;
        if (app.renderer) {
            app.renderer.setClearColor(0x000000, 0);

        }
    }

    // namespace for communicating with code generated by Puzzles
    app.ExternalInterface = {};
    prepareExternalInterface(app);
    if (PE) PE.viewportUseAppInstance(app);

    return app;
}


function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
    const container = document.getElementById(containerId);
    const fsButton = document.getElementById(fsButtonId);

    if (!fsButton) {
        return null;
    }
    if (!useFullscreen) {
        if (fsButton) fsButton.style.display = 'none';
        return null;
    }

    const fsEnabled = () => document.fullscreenEnabled
            || document.webkitFullscreenEnabled
            || document.mozFullScreenEnabled
            || document.msFullscreenEnabled;
    const fsElement = () => document.fullscreenElement
            || document.webkitFullscreenElement
            || document.mozFullScreenElement
            || document.msFullscreenElement;
    const requestFs = elem => (elem.requestFullscreen
            || elem.mozRequestFullScreen
            || elem.webkitRequestFullscreen
            || elem.msRequestFullscreen).call(elem);
    const exitFs = () => (document.exitFullscreen
            || document.mozCancelFullScreen
            || document.webkitExitFullscreen
            || document.msExitFullscreen).call(document);
    const changeFs = () => {
        const elem = fsElement();
        fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
        fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');
    };

    function fsButtonClick(event) {

        event.stopPropagation();
        if (fsElement()) {
            exitFs();
        } else {
            requestFs(container);
        }
    }

    if (fsEnabled()) fsButton.style.display = 'inline';

    fsButton.addEventListener('click', fsButtonClick);
    document.addEventListener('webkitfullscreenchange', changeFs);
    document.addEventListener('mozfullscreenchange', changeFs);
    document.addEventListener('msfullscreenchange', changeFs);
    document.addEventListener('fullscreenchange', changeFs);

    const disposeFullscreen = () => {
        fsButton.removeEventListener('click', fsButtonClick);
        document.removeEventListener('webkitfullscreenchange', changeFs);
        document.removeEventListener('mozfullscreenchange', changeFs);
        document.removeEventListener('msfullscreenchange', changeFs);
        document.removeEventListener('fullscreenchange', changeFs);
    }

    return disposeFullscreen;
}


function prepareExternalInterface(app) {
    /**
     * Register functions in the app.ExternalInterface to call them from
     * Puzzles, e.g:
     * app.ExternalInterface.myJSFunction = function() {
     *     console.log('Hello, World!');
     * }
     */
}

function runCode(app, puzzles) {
    // add your code here, e.g. console.log('Hello, World!');

    app.scene.children[0].position.y += 100;
    app.scene.children[0].position.z += 600;
    // app.scene.children[0].position.x += 10;

    displayGUI(app);

    const depthRangeSlider = parent.document.querySelector('.ms-range-slider-bar');
    if (depthRangeSlider) {
        depthRangeSlider.addEventListener('input', function(event) {
            bevelParams.extrusionDepth = Number(this.value);
            updateModel();
        });
    }

}

// functions to display svg model with default / updated attributes
let svgData, mergedMesh;

let bevelParams = {
    extrusionDepth: 30,
    bevelEnabled: true,
    bevelSize: 1,
    bevelSegments: 3
};

async function displaySVG(app, svgPath = './data/3dlogolab.svg', texturePath = './data/texture2.png') {
    // load SVG
    const loader = new SVGLoader();
    svgData = await loader.loadAsync(svgPath);

    // Normalize SVG size immediately after loading
    normalizeSVGSize();

    // load texture 
    let textureLoader = new threejs.TextureLoader();
    let texture = await textureLoader.loadAsync(texturePath);

    const mergedGeometries = updateGeometries();
    
    if (mergedMesh) {
        // just replace geometry
        mergedMesh.geometry = mergedGeometries;
    } else {
        // Create default material
        const material = new threejs.MeshStandardMaterial({
            roughness: 0,
            metalness: 1,
            side: threejs.DoubleSide,
            color: 0x808080
        });

        // Create new mesh with the preserved material
        mergedMesh = new threejs.Mesh(mergedGeometries, material);
        mergedMesh.scale.set(0.1, 0.1, 0.1)
        mergedMesh.rotation.x = Math.PI;
        mergedMesh.name = 'Merged Mesh';
        // Add mergedMesh to the scene
        app.scene.add(mergedMesh);
    }
}

window.displaySVG = displaySVG;

// New function to normalize SVG size
function normalizeSVGSize() {
    // Calculate the bounding box of the SVG
    let svgBoundingBox = new threejs.Box3();
    svgData.paths.forEach(path => {
        path.subPaths.forEach(subPath => {
            subPath.getPoints().forEach(point => {
                svgBoundingBox.expandByPoint(new threejs.Vector3(point.x, point.y, 0));
            });
        });
    });
    
    // Get the size and center of the SVG
    const svgSize = new threejs.Vector3();
    svgBoundingBox.getSize(svgSize);
    const svgCenter = new threejs.Vector3();
    svgBoundingBox.getCenter(svgCenter);
    
    // Target size for consistent scaling (200 units)
    const targetSize = 200;
    const svgMaxDimension = Math.max(svgSize.x, svgSize.y);
    const scaleFactor = targetSize / svgMaxDimension;
    
    // Scale and center all paths
    svgData.paths.forEach(path => {
        // Update subpaths directly since currentPath.scale is not a function
        path.subPaths.forEach(subPath => {
            subPath.curves.forEach(curve => {
                // Scale and center curve points
                if (curve.v0) {
                    curve.v0.x = (curve.v0.x - svgCenter.x) * scaleFactor;
                    curve.v0.y = (curve.v0.y - svgCenter.y) * scaleFactor;
                }
                if (curve.v1) {
                    curve.v1.x = (curve.v1.x - svgCenter.x) * scaleFactor;
                    curve.v1.y = (curve.v1.y - svgCenter.y) * scaleFactor;
                }
                if (curve.v2) {
                    curve.v2.x = (curve.v2.x - svgCenter.x) * scaleFactor;
                    curve.v2.y = (curve.v2.y - svgCenter.y) * scaleFactor;
                }
                if (curve.v3) {
                    curve.v3.x = (curve.v3.x - svgCenter.x) * scaleFactor;
                    curve.v3.y = (curve.v3.y - svgCenter.y) * scaleFactor;
                }
            });
        });
    });
}

function updateGeometries() {
    const geometries = [];
    
    // Calculate a scale factor based on the SVG's size
    // This will be used to adjust bevel parameters proportionally
    let svgBoundingBox = new threejs.Box3();
    svgData.paths.forEach(path => {
        path.subPaths.forEach(subPath => {
            subPath.getPoints().forEach(point => {
                svgBoundingBox.expandByPoint(new threejs.Vector3(point.x, point.y, 0));
            });
        });
    });
    
    const svgSize = new threejs.Vector3();
    svgBoundingBox.getSize(svgSize);
    const svgMaxDimension = Math.max(svgSize.x, svgSize.y);
    
    // Calculate the UV scale factor based on SVG size
    // This ensures consistent texture appearance regardless of SVG size
    const uvScaleFactor = 0.02 * (200 / svgMaxDimension);
    
    // Adjust bevel parameters based on SVG size
    // Larger SVGs will get proportionally larger bevels
    const scaledBevelSize = bevelParams.bevelSize * (svgMaxDimension / 200);
    
    // Loop through all of the parsed paths
    svgData.paths.forEach((path, i) => {
        const shapes = SVGLoader.createShapes(path);
        // Each path has array of shapes
        shapes.forEach((shape, j) => {
            // Finally we can take each shape and extrude it
            const geometry = new threejs.ExtrudeGeometry(shape, {
                bevelEnabled: bevelParams.bevelEnabled,
                bevelThickness: 1,
                bevelSize: scaledBevelSize,
                bevelSegments: bevelParams.bevelSegments,
                steps: 3,
                depth: bevelParams.extrusionDepth
            });

            // Scale UVs proportionally to the final geometry scaling
            const uvAttribute = geometry.attributes.uv;
            for (let i = 0; i < uvAttribute.count; i++) {
                uvAttribute.setXY(i, 
                    uvAttribute.getX(i) * uvScaleFactor, 
                    uvAttribute.getY(i) * uvScaleFactor
                );
            }

            geometries.push(geometry);
        }); 
    });

    // merging all the Extrude geometries into buffer geometry.
    let mergedGeometries = mergeBufferGeometries(geometries);

    mergedGeometries.deleteAttribute("normal");
    mergedGeometries = mergeVertices(mergedGeometries);
    mergedGeometries.computeVertexNormals();
    mergedGeometries.computeTangents();

    // Get group's size
    const box = new threejs.Box3().setFromBufferAttribute(mergedGeometries.attributes.position);
    const center = box.getCenter(new threejs.Vector3());
    // Center the geometry
    mergedGeometries.translate(-center.x, -center.y, -center.z);

    return mergedGeometries;
}

// this function is used to get the model's updated values
function updateModel() {
    // just replace geometry
    mergedMesh.geometry = updateGeometries();
}

function displayGUI(app) {

// Add GUI controls
    let gui = new GUI();
    gui.domElement.style.display = 'none';  // Hides the GUI by default

    gui.add(bevelParams, 'extrusionDepth', 0, 500, 1).onChange(function(value) {
        updateModel();
    });

    gui.add(bevelParams, 'bevelEnabled').onChange(function(value) {
        updateModel();
    });

    gui.add(bevelParams, 'bevelSize', 0, 50, 0.1).onChange(function(value) {
        updateModel();
    });
    
    gui.add(bevelParams, 'bevelSegments', 0, 10, 1).onChange(function(value) {
        updateModel();
    });

    // loading svg model
    let svgParams = {
        loadFile : function() { 
            document.getElementById('svgInput').click();
        }
    };
    gui.add(svgParams, 'loadFile').name("Upload your SVG");

    document.getElementById('svgInput').addEventListener('change', function(event) {
        let file = event.target.files[0];

        if (file) {
            let reader = new FileReader();
            reader.onload = function(e) {
                let image = new Image();
                image.onload = function() {
                    let texture = new threejs.Texture(image);
                    texture.needsUpdate = true;
                    const svgPath = e.target.result;
                    displaySVG(app, svgPath);
                };

                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    gui.add({ export: () => {

        if (app.scene.getObjectByName('Merged Mesh')) {
            exportGLTF(app.scene.getObjectByName('Merged Mesh'));
        } else {
            console.error('No mesh available for export.');
        }
    } }, 'export').name('Export GLTF');

    return gui;
}

function exportGLTF(input) {
    const exporter = new GLTFExporter();
    const options = {
        binary: false, // Set to true if you want a .glb file instead of .gltf
    };
    
    exporter.parse(input, (result) => {
        const output = JSON.stringify(result, null, 2);
        saveString(output, 'model.gltf');
    }, options);
}

function saveString(text, filename) {
    const blob = new Blob([text], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    URL.revokeObjectURL(link.href);
}